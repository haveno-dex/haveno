/*
 * This file is part of Haveno.
 *
 * Haveno is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at
 * your option) any later version.
 *
 * Haveno is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Haveno. If not, see <http://www.gnu.org/licenses/>.
 */

package haveno.core.api;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import haveno.common.ThreadUtils;
import haveno.common.UserThread;
import haveno.common.app.DevEnv;
import haveno.common.config.BaseCurrencyNetwork;
import haveno.common.config.Config;
import haveno.core.locale.Res;
import haveno.core.trade.HavenoUtils;
import haveno.core.user.Preferences;
import haveno.core.xmr.model.EncryptedConnectionList;
import haveno.core.xmr.nodes.XmrNodes;
import haveno.core.xmr.nodes.XmrNodes.XmrNode;
import haveno.core.xmr.nodes.XmrNodesSetupPreferences;
import haveno.core.xmr.setup.DownloadListener;
import haveno.core.xmr.setup.WalletsSetup;
import haveno.network.Socks5ProxyProvider;
import haveno.network.p2p.P2PService;
import haveno.network.p2p.P2PServiceListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import org.apache.commons.lang3.exception.ExceptionUtils;

import javafx.beans.property.IntegerProperty;
import javafx.beans.property.LongProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.ReadOnlyDoubleProperty;
import javafx.beans.property.ReadOnlyIntegerProperty;
import javafx.beans.property.ReadOnlyLongProperty;
import javafx.beans.property.ReadOnlyObjectProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleLongProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import monero.common.MoneroConnectionManager;
import monero.common.MoneroConnectionManagerListener;
import monero.common.MoneroError;
import monero.common.MoneroRpcConnection;
import monero.common.MoneroRpcError;
import monero.common.TaskLooper;
import monero.daemon.MoneroDaemonRpc;
import monero.daemon.model.MoneroDaemonInfo;
import monero.daemon.model.MoneroTx;

@Slf4j
@Singleton
public final class XmrConnectionService {

    private static final int MIN_BROADCAST_CONNECTIONS = 0; // TODO: 0 for stagenet, 5+ for mainnet
    private static final long REFRESH_PERIOD_HTTP_MS = 20000; // refresh period when connected to remote node over http
    private static final long REFRESH_PERIOD_ONION_MS = 30000; // refresh period when connected to remote node over tor
    private static final long KEY_IMAGE_REFRESH_PERIOD_MS_LOCAL = 20000; // 20 seconds
    private static final long KEY_IMAGE_REFRESH_PERIOD_MS_REMOTE = 300000; // 5 minutes
    private static final int SYNC_TOLERANCE_NUM_BLOCKS = 3;
    private static final boolean USE_BOOTSTRAP_HEIGHT = false;
    private static final long STAGGER_MS = 1500; // stagger connection checks
    private static final String LAST_INFO_KEY = "lastInfo";
    private static int numConsecutiveErrors = 0;

    public enum XmrConnectionFallbackType {
        LOCAL,
        CUSTOM,
        PROVIDED
    }

    private final Object lock = new Object();
    private final Object pollLock = new Object();
    private final Object listenerLock = new Object();
    private final Config config;
    private final CoreContext coreContext;
    private final Preferences preferences;
    private final CoreAccountService accountService;
    private final XmrNodes xmrNodes;
    private final XmrLocalNode xmrLocalNode;
    private final EncryptedConnectionList connectionList;
    private List<MoneroRpcConnection> connections = new ArrayList<MoneroRpcConnection>();
    private final ObjectProperty<MoneroRpcConnection> connectionProperty = new SimpleObjectProperty<>();
    private final ObjectProperty<List<MoneroRpcConnection>> connectionsProperty = new SimpleObjectProperty<>(); // TODO: redundant with connections
    private final IntegerProperty numConnections = new SimpleIntegerProperty(-1);
    private final LongProperty chainHeight = new SimpleLongProperty(0);
    private final DownloadListener downloadListener = new DownloadListener();
    @Getter
    private final ObjectProperty<XmrConnectionFallbackType> connectionServiceFallbackType = new SimpleObjectProperty<>();
    @Getter
    private final StringProperty connectionServiceErrorMsg = new SimpleStringProperty();
    private final LongProperty numUpdates = new SimpleLongProperty(0);
    private Socks5ProxyProvider socks5ProxyProvider;

    private boolean isInitialized;
    private boolean pollInProgress;
    private MoneroDaemonRpc monerod;
    private Long connectionTimeout;
    private Boolean isConnected = false;
    @Getter
    private MoneroDaemonInfo lastInfo;
    private Long lastFallbackInvocation;
    private Long lastLogPollErrorTimestamp;
    private long lastLogMonerodNotSyncedTimestamp;
    private Long syncStartHeight;
    private TaskLooper monerodPoller;
    private long lastRefreshPeriodMs;
    private boolean wasMonerodSynced;
    @Getter
    private boolean isShutDownStarted;
    private List<MoneroConnectionManagerListener> listeners = new ArrayList<>();
    private XmrKeyImagePoller keyImagePoller;
    private final Map<String, Optional<MoneroTx>> txCache = new HashMap<String, Optional<MoneroTx>>();

    // connection switching
    private static final int EXCLUDE_CONNECTION_SECONDS = 180;
    private static final int MAX_SWITCH_REQUESTS_PER_MINUTE = 2;
    private static final int SKIP_SWITCH_WITHIN_MS = 10000;
    private int numRequestsLastMinute;
    private long lastSwitchTimestamp;
    private Set<MoneroRpcConnection> excludedConnections = new HashSet<>();
    private static final long FALLBACK_INVOCATION_PERIOD_MS = 1000 * 30 * 1; // offer to fallback up to once every 30s
    private boolean fallbackApplied;
    private boolean usedSyncingLocalNodeBeforeStartup;
    private boolean localNodeStartedFromPrompt = false;

    @Inject
    public XmrConnectionService(P2PService p2PService,
                                        Config config,
                                        CoreContext coreContext,
                                        Preferences preferences,
                                        WalletsSetup walletsSetup,
                                        CoreAccountService accountService,
                                        XmrNodes xmrNodes,
                                        XmrLocalNode xmrLocalNode,
                                        MoneroConnectionManager connectionManager,
                                        EncryptedConnectionList connectionList,
                                        Socks5ProxyProvider socks5ProxyProvider) {
        this.config = config;
        this.coreContext = coreContext;
        this.preferences = preferences;
        this.accountService = accountService;
        this.xmrNodes = xmrNodes;
        this.xmrLocalNode = xmrLocalNode;
        this.connectionList = connectionList;
        this.socks5ProxyProvider = socks5ProxyProvider;

        // set static references in HavenoUtils // TODO: better way?
        HavenoUtils.preferences = preferences;

        // initialize when connected to p2p network
        p2PService.addP2PServiceListener(new P2PServiceListener() {
            @Override
            public void onTorNodeReady() {
                ThreadUtils.submitToPool(() -> {
                    try {
                        initialize();
                    } catch (Exception e) {
                        log.warn("Error initializing connection service, error={}\n", e.getMessage(), e);
                    }
                });
            }
            @Override
            public void onHiddenServicePublished() {}
            @Override
            public void onDataReceived() {}
            @Override
            public void onNoSeedNodeAvailable() {}
            @Override
            public void onNoPeersAvailable() {}
            @Override
            public void onUpdatedDataReceived() {}
        });
    }

    public void onShutDownStarted() {
        log.info("{}.onShutDownStarted()", getClass().getSimpleName());
        isShutDownStarted = true;
    }

    public void shutDown() {
        log.info("Shutting down {}", getClass().getSimpleName());
        isInitialized = false;
        synchronized (lock) {
            if (monerodPoller != null) monerodPoller.stop();
            monerod = null;
        }
    }

    // ------------------------ CONNECTION MANAGEMENT -------------------------

    public MoneroDaemonRpc getMonerod() {
        accountService.checkAccountOpen();
        return this.monerod;
    }

    public String getProxyUri() {
        return socks5ProxyProvider.getSocks5Proxy() == null ? null : socks5ProxyProvider.getSocks5Proxy().getInetAddress().getHostAddress() + ":" + socks5ProxyProvider.getSocks5Proxy().getPort();
    }

    public void addConnectionListener(MoneroConnectionManagerListener listener) {
        synchronized (listenerLock) {
            listeners.add(listener);
        }
    }

    public Boolean isConnected() {
        return isConnected;
    }

    public void addConnection(MoneroRpcConnection connection) {
        addConnection(connection, true);
    }

    private void addConnection(MoneroRpcConnection connection, boolean addToEncryptedList) {
        accountService.checkAccountOpen();
        synchronized (connections) {
            if (getConnection(connection.getUri()) != null) throw new IllegalArgumentException("Connection already exists with URI: " + connection.getUri());
            connections.add(connection);
        }
        if (addToEncryptedList && coreContext.isApiUser()) connectionList.addConnection(connection);
    }

    public void removeConnection(String uri) {
        accountService.checkAccountOpen();
        connectionList.removeConnection(uri);
        synchronized (connections) {
            MoneroRpcConnection toRemove = null;
            for (MoneroRpcConnection connection : connections) {
                if (connection.getUri().equals(uri)) {
                    toRemove = connection;
                    break;
                }
            }
            if (toRemove != null) connections.remove(toRemove);
        }
    }

    public MoneroRpcConnection getConnection() {
        accountService.checkAccountOpen();
        Optional<String> currentConnectionUri = connectionList.getCurrentConnectionUri();
        return currentConnectionUri.isPresent() ? getConnection(currentConnectionUri.get()) : null;
    }

    public boolean hasConnection(String uri) {
        return getConnection(uri) != null;
    }

    public MoneroRpcConnection getConnection(String connectionUri) {
        accountService.checkAccountOpen();
        synchronized (connections) {
            for (MoneroRpcConnection connection : connections) {
                if (connection.getUri().equals(connectionUri)) {
                    return connection;
                }
            }
            return null;
        }
    }

    public List<MoneroRpcConnection> getConnections() {
        accountService.checkAccountOpen();
        synchronized (connections) {
            return connections;
        }
    }

    public void setConnection(String connectionUri) {
        accountService.checkAccountOpen();
        MoneroRpcConnection connection = getConnection(connectionUri);
        if (connection == null) connection = new MoneroRpcConnection(connectionUri);
        setConnection(connection, null);
    }

    public void setConnection(MoneroRpcConnection connection) {
        accountService.checkAccountOpen();
        setConnection(connection, null);
    }

    private void setConnection(MoneroRpcConnection connection, MoneroDaemonInfo info) {
        log.info("XmrConnectionService.setConnection() called with connection: " + connection);

        if (isShutDownStarted || !accountService.isAccountOpen()) return;
        if (connection == null) {
            log.warn("Setting monerod connection to null", new Throwable("Stack trace"));
        }

        // update internals if applicable
        boolean isInitializing = monerod == null && connection != null;
        if (isInitializing || !HavenoUtils.connectionConfigsEqual(connection, getConnection()) || !isPolling() || lastRefreshPeriodMs != getRefreshPeriodMs()) {
            synchronized (lock) {
                if (connection == null) {
                    monerod = null;
                    isConnected = false;
                    connectionList.setCurrentConnectionUri(null);
                } else {
                    monerod = new MoneroDaemonRpc(connection);
                    isConnected = connection.isConnected();
                    synchronized (connections) {
                        removeConnection(connection.getUri());
                        addConnection(connection);
                    }
                    connectionList.setCurrentConnectionUri(connection.getUri());
                }

                // set connection property on user thread
                UserThread.execute(() -> {
                    connectionProperty.set(connection);
                    numUpdates.set(numUpdates.get() + 1);
                });
            }

            // update key image poller
            keyImagePoller.setMonerod(getMonerod());
            keyImagePoller.setRefreshPeriodMs(getKeyImageRefreshPeriodMs());

            // restart polling
            lastRefreshPeriodMs = getRefreshPeriodMs();
            if (wasMonerodSynced) {
                updatePolling(info); // restart polling off thread after connection established
            } else {
                tryPollMonerod(info); // poll immediately before connection established
                if (connection != getConnection()) return; // polling can change connection
                UserThread.runAfter(() -> updatePolling(null), getInternalRefreshPeriodMs() / 1000);
            }
        }

        // notify listeners in parallel
        synchronized (listenerLock) {
            for (MoneroConnectionManagerListener listener : listeners) {
                ThreadUtils.submitToPool(() -> listener.onConnectionChanged(connection));
            }
        }
    }

    public MoneroRpcConnection checkConnection() {
        accountService.checkAccountOpen();
        MoneroRpcConnection connection = getConnection();
        checkConnection(connection);
        return connection;
    }

    public MoneroRpcConnection getBestConnection() {
        return getBestConnection(null);
    }

    private MoneroRpcConnection getBestConnection(Collection<MoneroRpcConnection> ignoredConnections) {
        accountService.checkAccountOpen();

        // skip if user needs prompted
        if (promptToStartLocalNode()) {
            log.warn("Cannot get best connection on startup because user needs to be prompted");
            return null;
        }

        // copy connections for thread safety
        List<MoneroRpcConnection> connectionsCopy;
        synchronized (connections) {
            connectionsCopy = new ArrayList<MoneroRpcConnection>(getConnections());
        }

        // get best connection
        Set<MoneroRpcConnection> ignoredConnectionsSet = new HashSet<>();
        if (ignoredConnections != null) ignoredConnectionsSet.addAll(ignoredConnections);
        addLocalNodeIfIgnored(ignoredConnectionsSet);
        MoneroRpcConnection bestConnection = getBestConnection(connectionsCopy, ignoredConnectionsSet);

        // return only connection if no best connection
        if (bestConnection == null && connectionsCopy.size() == 1 && !ignoredConnectionsSet.contains(connectionsCopy.get(0))) {
            return connectionsCopy.get(0);
        }

        return bestConnection;
    }

    private static MoneroRpcConnection getBestConnection(Collection<MoneroRpcConnection> connections, Collection<MoneroRpcConnection> ignoredConnections) {
        log.info("Getting best Monero connection, ignoring " + (ignoredConnections == null ? 0 : ignoredConnections.size()) + " connections");

        // try connections within each ascending priority
        AtomicReference<MoneroRpcConnection> bestConnection = new AtomicReference<>();
        MoneroRpcConnection bestUnsyncedConnection = null;
        for (List<MoneroRpcConnection> prioritizedConnections : getConnectionsInAscendingPriority(connections)) {
            try {

                // shuffle connections within same priority
                Collections.shuffle(prioritizedConnections);
            
                // check connections staggered
                int numTasks = 0;
                ExecutorService pool = Executors.newFixedThreadPool(prioritizedConnections.size());
                CompletionService<MoneroRpcConnection> completionService = new ExecutorCompletionService<MoneroRpcConnection>(pool);
                for (int i = 0; i < prioritizedConnections.size(); i++) {
                    MoneroRpcConnection connection = prioritizedConnections.get(i);
                    if (ignoredConnections != null && ignoredConnections.contains(connection)) continue;
                    numTasks++;
                    final int delay = i;
                    completionService.submit(() -> {
                        if (delay > 0) Thread.sleep(delay * STAGGER_MS); // stagger start
                        if (bestConnection.get() == null) checkConnection(connection); // check connection if best not found
                        return connection;
                    });
                }

                // use first available and synced connection
                pool.shutdown();
                for (int i = 0; i < numTasks; i++) {
                    try {
                        MoneroRpcConnection connection = completionService.take().get();
                        if (Boolean.TRUE.equals(connection.isConnected())) {
                            if (isSyncedWithinTolerance(getCachedDaemonInfo(connection))) {
                                bestConnection.set(connection);
                                return connection;
                            } else if (bestUnsyncedConnection == null) {
                                bestUnsyncedConnection = connection;
                            }
                        }
                    } catch (Exception e) {
                        // ignore error connecting
                    }
                }
            } catch (Exception e) {
                log.warn("Error checking prioritized connections: " + e.getMessage() + ". That should never happen.");
                throw new MoneroError(e);
            }
        }
        if (bestUnsyncedConnection == null) {
            log.warn("There is no best Monero connection detected");
        } else {
            log.warn("The best Monero connection is not synced");
        }
        return bestUnsyncedConnection;
    }

    private static List<List<MoneroRpcConnection>> getConnectionsInAscendingPriority(Collection<MoneroRpcConnection> connections) {
        Map<Integer, List<MoneroRpcConnection>> connectionPriorities = new TreeMap<Integer, List<MoneroRpcConnection>>();
        for (MoneroRpcConnection connection : connections) {
            if (!connectionPriorities.containsKey(connection.getPriority())) connectionPriorities.put(connection.getPriority(), new ArrayList<MoneroRpcConnection>());
            connectionPriorities.get(connection.getPriority()).add(connection);
        }
        List<List<MoneroRpcConnection>> prioritizedConnections = new ArrayList<List<MoneroRpcConnection>>();
        for (List<MoneroRpcConnection> priorityConnections : connectionPriorities.values()) prioritizedConnections.add(priorityConnections);
        if (connectionPriorities.containsKey(0)) prioritizedConnections.add(prioritizedConnections.remove(0)); // move priority 0 to end
        return prioritizedConnections;
    }

    private boolean promptToStartLocalNode() {
        return !wasMonerodSynced && !fallbackApplied && usedSyncingLocalNodeBeforeStartup && !xmrLocalNode.isDetected(); // we give user the chance to start local node on startup if previously used
    }

    private void addLocalNodeIfIgnored(Collection<MoneroRpcConnection> ignoredConnections) {
        synchronized (connections) {
            if (xmrLocalNode.shouldBeIgnored() && hasConnection(xmrLocalNode.getUri())) ignoredConnections.add(getConnection(xmrLocalNode.getUri()));
        }
    }

    private boolean canSwitchToBestConnection() {
        return !isFixedConnection() && isAutoSwitch() && !promptToStartLocalNode();
    }

    private MoneroRpcConnection switchToBestConnection() {
        return switchToBestConnection(null, true);
    }

    private MoneroRpcConnection switchToBestConnection(Collection<MoneroRpcConnection> ignoredConnections, boolean logWarning) {
        if (!canSwitchToBestConnection()) {
            if (logWarning) log.warn("Cannot switch to best Monero connection because connection is fixed, auto switch is disabled, or fallback is required");
            return null;
        }
        MoneroRpcConnection bestConnection = getBestConnection(ignoredConnections);
        if (bestConnection != null) setConnection(bestConnection, getCachedDaemonInfo(bestConnection));
        return bestConnection;
    }

    public synchronized boolean requestSwitchToNextBestConnection() {
        return requestSwitchToNextBestConnection(null);
    }

    public synchronized boolean requestSwitchToNextBestConnection(MoneroRpcConnection sourceConnection) {
        log.warn("Requesting switch to next best monerod, source monerod={}, proxyUri={}", sourceConnection == null ? null : sourceConnection.getUri(), sourceConnection == null ? null : sourceConnection.getProxyUri());
        if (Config.baseCurrencyNetwork() == BaseCurrencyNetwork.XMR_LOCAL) {
            try {
                throw new RuntimeException("Requesting connection switch on testnet");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // skip if shut down started
        if (isShutDownStarted) {
            log.warn("Skipping switch to next best Monero connection because shut down has started");
            return false;
        }

        // skip if connection is already switched
        if (sourceConnection != null && sourceConnection != getConnection()) {
            log.warn("Skipping switch to next best Monero connection because source connection is not current connection");
            return false;
        }

        // skip if connection is fixed
        if (isFixedConnection() || !isAutoSwitch()) {
            log.warn("Skipping switch to next best Monero connection because connection is fixed or auto switch is disabled");
            return false;
        }

        // skip if last switch was too recent
        boolean skipSwitch = System.currentTimeMillis() - lastSwitchTimestamp < SKIP_SWITCH_WITHIN_MS;
        if (skipSwitch) {
            log.warn("Skipping switch to next best Monero connection because last switch was less than {} seconds ago", SKIP_SWITCH_WITHIN_MS / 1000);
            return false;
        }

        // skip if too many requests in the last minute
        if (numRequestsLastMinute > MAX_SWITCH_REQUESTS_PER_MINUTE) {
            log.warn("Skipping switch to next best Monero connection because more than {} requests were made in the last minute", MAX_SWITCH_REQUESTS_PER_MINUTE);
            return false;
        }

        // increment request count
        numRequestsLastMinute++;
        UserThread.runAfter(() -> numRequestsLastMinute--, 60); // decrement after one minute

        // exclude current connection
        MoneroRpcConnection currentConnection = getConnection();
        if (currentConnection != null) excludedConnections.add(currentConnection);

        // get connection to switch to
        MoneroRpcConnection bestConnection = getBestConnection(excludedConnections);

        // remove from excluded connections after period
        UserThread.runAfter(() -> {
            if (currentConnection != null) excludedConnections.remove(currentConnection);
        }, EXCLUDE_CONNECTION_SECONDS);

        // return if no connection to switch to
        if (bestConnection == null || !Boolean.TRUE.equals(bestConnection.isConnected())) {
            return false;
        }

        // switch to best connection
        lastSwitchTimestamp = System.currentTimeMillis();
        setConnection(bestConnection, getCachedDaemonInfo(bestConnection));
        return true;
    }

    public void setAutoSwitch(boolean autoSwitch) {
        accountService.checkAccountOpen();
        connectionList.setAutoSwitch(autoSwitch);
    }

    public boolean getAutoSwitch() {
        accountService.checkAccountOpen();
        return connectionList.getAutoSwitch();
    }

    public boolean isConnectionLocalHost() {
        return isConnectionLocalHost(getConnection());
    }

    public boolean isProxyApplied() {
        return isProxyApplied(getConnection());
    }

    public long getRefreshPeriodMs() {
        return connectionList.getRefreshPeriod() > 0 ? connectionList.getRefreshPeriod() : getDefaultRefreshPeriodMs(false);
    }

    private long getInternalRefreshPeriodMs() {
        return connectionList.getRefreshPeriod() > 0 ? connectionList.getRefreshPeriod() : getDefaultRefreshPeriodMs(true);
    }

    public void verifyConnection() {
        if (monerod == null) throw new RuntimeException("No connection to Monero node");
        if (!Boolean.TRUE.equals(isConnected())) throw new RuntimeException("No connection to Monero node");
        if (!isSyncedWithinTolerance()) throw new RuntimeException("Monero node is not synced");
    }

    public Long getHeight() {
        return getHeight(lastInfo);
    }

    private static Long getHeight(MoneroDaemonInfo info) {
        if (info == null) return null;
        if (USE_BOOTSTRAP_HEIGHT) return info.getHeight();
        return info.getHeightWithoutBootstrap() == null || info.getHeightWithoutBootstrap() == 0 ? info.getHeight() : info.getHeightWithoutBootstrap();
    }

    public Long getTargetHeight() {
        return getTargetHeight(lastInfo);
    }

    private static Long getTargetHeight(MoneroDaemonInfo info) {
        if (info == null) return null;
        return info.getTargetHeight() == 0 ? info.getHeight() : info.getTargetHeight();
    }

    private static int getNumOutgoingConnections(MoneroDaemonInfo info) {
        return info == null || Boolean.TRUE.equals(info.isRestricted()) ? -1 : info.getNumOutgoingConnections();
    }

    public boolean isSyncedWithinTolerance() {
        return isSyncedWithinTolerance(lastInfo);
    }

    public XmrKeyImagePoller getKeyImagePoller() {
        synchronized (lock) {
            if (keyImagePoller == null) keyImagePoller = new XmrKeyImagePoller();
            return keyImagePoller;
        }
    }

    private long getKeyImageRefreshPeriodMs() {
        return isConnectionLocalHost() ? KEY_IMAGE_REFRESH_PERIOD_MS_LOCAL : KEY_IMAGE_REFRESH_PERIOD_MS_REMOTE;
    }

    // ----------------------------- APP METHODS ------------------------------

    public ReadOnlyIntegerProperty numConnectionsProperty() {
        return numConnections;
    }

    public ReadOnlyObjectProperty<List<MoneroRpcConnection>> connectionsProperty() {
        return connectionsProperty;
    }

    public ReadOnlyObjectProperty<MoneroRpcConnection> connectionProperty() {
        return connectionProperty;
    }

    public boolean hasSufficientPeersForBroadcast() {
        if (numConnections.get() < 0) return true; // we don't know how many connections we have, but that's expected with restricted node
        return numConnections.get() >= getMinBroadcastConnections();
    }

    public LongProperty chainHeightProperty() {
        return chainHeight;
    }

    public ReadOnlyDoubleProperty downloadPercentageProperty() {
        return downloadListener.percentageProperty();
    }

    public int getMinBroadcastConnections() {
        return MIN_BROADCAST_CONNECTIONS;
    }

    public boolean isDownloadComplete() {
        return downloadPercentageProperty().get() == 1d;
    }

    public ReadOnlyLongProperty numUpdatesProperty() {
        return numUpdates;
    }

    public void fallbackToBestConnection() {
        stopPolling();
        if (isShutDownStarted) return;
        fallbackApplied = true;
        if (isProvidedConnections() || xmrNodes.getProvidedXmrNodes().isEmpty()) {
            log.warn("Falling back to public nodes");
            preferences.setMoneroNodesOptionOrdinal(XmrNodes.MoneroNodesOption.PUBLIC.ordinal());
            initializeConnections();
        } else {
            log.warn("Falling back to provided nodes");
            preferences.setMoneroNodesOptionOrdinal(XmrNodes.MoneroNodesOption.PROVIDED.ordinal());
            initializeConnections();
            if (getConnection() == null) {
                log.warn("No provided nodes available, falling back to public nodes");
                fallbackToBestConnection();
            }
        }
    }

    public MoneroTx getTx(String txHash) {
        List<MoneroTx> txs = getTxs(Arrays.asList(txHash));
        return txs.isEmpty() ? null : txs.get(0);
    }

    public List<MoneroTx> getTxs(List<String> txHashes) {
        synchronized (txCache) {

            // fetch txs
            if (getMonerod() == null) verifyConnection(); // will throw
            List<MoneroTx> txs = getMonerod().getTxs(txHashes, true);

            // store to cache
            for (MoneroTx tx : txs) txCache.put(tx.getHash(), Optional.of(tx));

            // schedule txs to be removed from cache
            UserThread.runAfter(() -> {
                synchronized (txCache) {
                    for (MoneroTx tx : txs) txCache.remove(tx.getHash());
                }
            }, getRefreshPeriodMs() / 1000);
            return txs;
        }
    }

    public MoneroTx getTxWithCache(String txHash) {
        List<MoneroTx> cachedTxs = getTxsWithCache(Arrays.asList(txHash));
        return cachedTxs.isEmpty() ? null : cachedTxs.get(0);
    }

    public List<MoneroTx> getTxsWithCache(List<String> txHashes) {
        synchronized (txCache) {
            try {
                // get cached txs
                List<MoneroTx> cachedTxs = new ArrayList<MoneroTx>();
                List<String> uncachedTxHashes = new ArrayList<String>();
                for (int i = 0; i < txHashes.size(); i++) {
                    if (txCache.containsKey(txHashes.get(i))) cachedTxs.add(txCache.get(txHashes.get(i)).orElse(null));
                    else uncachedTxHashes.add(txHashes.get(i));
                }

                // return txs from cache if available, otherwise fetch
                return uncachedTxHashes.isEmpty() ? cachedTxs : getTxs(txHashes);
            } catch (Exception e) {
                if (!isShutDownStarted) throw e;
                return null;
            }
        }
    }

    // ---------------------------- STATIC UTILS -----------------------------

    protected static boolean isProxyApplied(MoneroRpcConnection connection) {
        if (connection == null) return false;
        return connection.isOnion() || (HavenoUtils.preferences.getUseTorForXmr().isUseTorForXmr() && !HavenoUtils.isPrivateIp(connection.getUri()));
    }

    protected static void checkConnection(MoneroRpcConnection connection) {
        long startTime = System.currentTimeMillis();
        try {
            connection.setTimeout(getTimeoutMs(connection));
            MoneroDaemonRpc monerod = new MoneroDaemonRpc(connection);
            MoneroDaemonInfo info = monerod.getInfo();
            connection.setOnline(getNumOutgoingConnections(info) != 0);
            connection.setAuthenticated(true);
            connection.setAttribute(LAST_INFO_KEY, info);
        } catch (Exception e) {
            connection.setOnline(false);
            if (e instanceof MoneroRpcError) {
                if (((MoneroRpcError) e).getCode() == 401) {
                    connection.setOnline(true);
                    connection.setAuthenticated(false);
                }
            } else {
                connection.setOnline(false);
                connection.setAuthenticated(null);
            }
            connection.setAttribute(LAST_INFO_KEY, null);
        }
        if (Boolean.TRUE.equals(connection.isOnline())) {
            connection.setResponseTime(System.currentTimeMillis() - startTime);
        }
    }

    protected static long getTimeoutMs(MoneroRpcConnection connection) {
        if (HavenoUtils.isLocalHost(connection.getUri())) {
            return XmrLocalNode.REFRESH_PERIOD_LOCAL_MS;
        } else if (isProxyApplied(connection)) {
            return REFRESH_PERIOD_ONION_MS;
        } else {
            return REFRESH_PERIOD_HTTP_MS;
        }
    }

    protected static MoneroDaemonInfo getCachedDaemonInfo(MoneroRpcConnection connection) {
        return (MoneroDaemonInfo) connection.getAttribute(LAST_INFO_KEY);
    }

    protected static boolean isSyncedWithinTolerance(MoneroDaemonInfo info) {
        Long targetHeight = getTargetHeight(info);
        if (targetHeight == null) return false;
        if (targetHeight - getHeight(info) <= SYNC_TOLERANCE_NUM_BLOCKS) return true; // synced if within 3 blocks of target height
        return false;
    }

    // ------------------------------- HELPERS --------------------------------

    private void doneDownload() {
        wasMonerodSynced = true;
        downloadListener.doneDownload();
    }

    private boolean isConnectionLocalHost(MoneroRpcConnection connection) {
        return connection != null && HavenoUtils.isLocalHost(connection.getUri());
    }

    private long getDefaultRefreshPeriodMs(boolean internal) {
        MoneroRpcConnection connection = getConnection();
        if (connection == null) return XmrLocalNode.REFRESH_PERIOD_LOCAL_MS;
        if (isConnectionLocalHost(connection)) {
            if (internal) return XmrLocalNode.REFRESH_PERIOD_LOCAL_MS;
            if (lastInfo != null && (lastInfo.getHeightWithoutBootstrap() != null && lastInfo.getHeightWithoutBootstrap() > 0 && lastInfo.getHeightWithoutBootstrap() < lastInfo.getHeight())) {
                return REFRESH_PERIOD_HTTP_MS; // refresh slower if syncing or bootstrapped
            } else {
                return XmrLocalNode.REFRESH_PERIOD_LOCAL_MS; // TODO: announce faster refresh after done syncing
            }
        } else if (isProxyApplied(connection)) {
            return REFRESH_PERIOD_ONION_MS;
        } else {
            return REFRESH_PERIOD_HTTP_MS;
        }
    }

    private void initialize() {

        // initialize key image poller
        getKeyImagePoller();
        new Thread(() -> {
            HavenoUtils.waitFor(20000);
            keyImagePoller.poll(); // TODO: keep or remove first poll?s
        }).start();

        // listen for account to be opened or password changed
        if (!isInitialized) {
            accountService.addListener(new AccountServiceListener() {

                @Override
                public void onAccountOpened() {
                    try {
                        log.info(getClass() + ".onAccountOpened() called");
                        initialize();
                    } catch (Exception e) {
                        log.error("Error initializing connection service after account opened, error={}\n", e.getMessage(), e);
                        throw new RuntimeException(e);
                    }
                }

                @Override
                public void onPasswordChanged(String oldPassword, String newPassword) {
                    log.info(getClass() + ".onPasswordChanged({}, {}) called", oldPassword == null ? null : "***", newPassword == null ? null : "***");
                    connectionList.changePassword(oldPassword, newPassword);
                }
            });
        }

        // initialize connections
        initializeConnections();
    }

    private void initializeConnections() {
        MoneroRpcConnection initialConnection = null;
        MoneroDaemonInfo initialInfo = null;
        synchronized (lock) {

            // reset connection manager
            synchronized (connections) {
                connections.clear();
            }

            // run once
            if (!isInitialized) {

                // register local node listener
                xmrLocalNode.addListener(new XmrLocalNodeListener() {
                    @Override
                    public void onNodeStarted(MoneroDaemonRpc monerod) {
                        log.info("Local monero node started, height={}", monerod.getHeight());
                    }

                    @Override
                    public void onNodeStopped() {
                        log.info("Local monero node stopped");
                    }

                    @Override
                    public void onConnectionChanged(MoneroRpcConnection connection) {
                        log.info("Local monerod connection changed: " + connection);

                        // skip if ignored
                        if (isShutDownStarted || !isAutoSwitch() || !accountService.isAccountOpen() ||
                            !hasConnection(connection.getUri()) || xmrLocalNode.shouldBeIgnored()) return;

                        // check connection
                        boolean isConnectedAndSynced = false;
                        if (xmrLocalNode.isConnected()) {
                            MoneroRpcConnection conn = getConnection(connection.getUri());
                            checkConnection(conn);
                            isConnectedAndSynced = Boolean.TRUE.equals(conn.isConnected()) && isSyncedWithinTolerance(getCachedDaemonInfo(conn));
                        }

                        // update connection
                        boolean isCurrentConnection = getConnection() != null && getConnection().getUri().equals(connection.getUri());
                        if (isConnectedAndSynced) {
                            setConnection(connection.getUri());

                            // reset error connecting to local node
                            if (connectionServiceFallbackType.get() == XmrConnectionFallbackType.LOCAL && isConnectionLocalHost()) {
                                connectionServiceFallbackType.set(null);
                            }
                        } else if (isCurrentConnection && !promptToStartLocalNode() && !localNodeStartedFromPrompt) {
                            switchToBestConnection(); // TODO: what if this is called before initialized?
                        }
                    }
                });
            }

            // set if last node was locally syncing
            if (!isInitialized) {
                usedSyncingLocalNodeBeforeStartup = connectionList.getCurrentConnectionUri().isPresent() && xmrLocalNode.equalsUri(connectionList.getCurrentConnectionUri().get()) && Boolean.TRUE.equals(preferences.getXmrNodeSettings().getSyncBlockchain());
            }

            // restore connections
            if (!isFixedConnection()) {

                // load previous or default connections
                if (coreContext.isApiUser()) {

                    // load previous connections
                    for (MoneroRpcConnection connection : connectionList.getConnections()) addConnection(connection, false);
                    log.info("Read " + connectionList.getConnections().size() + " previous connections from disk");

                    // add default connections
                    for (XmrNode node : xmrNodes.getAllXmrNodes()) {
                        if (node.hasClearNetAddress()) {
                            if (!xmrLocalNode.shouldBeIgnored() || !xmrLocalNode.equalsUri(node.getClearNetUri())) {
                                MoneroRpcConnection connection = new MoneroRpcConnection(node.getHostNameOrAddress() + ":" + node.getPort()).setPriority(node.getPriority());
                                if (!connectionList.hasConnection(connection.getUri())) addConnection(connection);
                            }
                        }
                        if (node.hasOnionAddress()) {
                            MoneroRpcConnection connection = new MoneroRpcConnection(node.getOnionAddress() + ":" + node.getPort()).setPriority(node.getPriority());
                            if (!connectionList.hasConnection(connection.getUri())) addConnection(connection);
                        }
                    }
                } else {

                    // add default connections
                    for (XmrNode node : xmrNodes.selectPreferredNodes(new XmrNodesSetupPreferences(preferences))) {
                        if (node.hasClearNetAddress()) {
                            if (!xmrLocalNode.shouldBeIgnored() || !xmrLocalNode.equalsUri(node.getClearNetUri())) {
                                MoneroRpcConnection connection = new MoneroRpcConnection(node.getHostNameOrAddress() + ":" + node.getPort()).setPriority(node.getPriority());
                                addConnection(connection);
                            }
                        }
                        if (node.hasOnionAddress()) {
                            MoneroRpcConnection connection = new MoneroRpcConnection(node.getOnionAddress() + ":" + node.getPort()).setPriority(node.getPriority());
                            addConnection(connection);
                        }
                    }
                }

                // restore last connection
                if (connectionList.getCurrentConnectionUri().isPresent() && hasConnection(connectionList.getCurrentConnectionUri().get())) {
                    if (!xmrLocalNode.shouldBeIgnored() || !xmrLocalNode.equalsUri(connectionList.getCurrentConnectionUri().get())) {
                        initialConnection = getConnection(connectionList.getCurrentConnectionUri().get());
                    }
                }

                // set connection proxies
                log.info("TOR proxy URI: " + getProxyUri());
                synchronized (connections) {
                    for (MoneroRpcConnection connection : connections) {
                        if (isProxyApplied(connection)) connection.setProxyUri(getProxyUri());
                    }
                }

                // update connection
                if (canSwitchToBestConnection()) {
                    MoneroRpcConnection bestConnection = getBestConnection();
                    if (bestConnection != null) initialConnection = bestConnection;
                    if (initialConnection != null) initialInfo = getCachedDaemonInfo(initialConnection);
                }
            } else if (!isInitialized) {

                // set connection from startup argument if given
                MoneroRpcConnection connection = new MoneroRpcConnection(config.xmrNode, config.xmrNodeUsername, config.xmrNodePassword).setPriority(1);
                if (isProxyApplied(connection)) connection.setProxyUri(getProxyUri());
                initialConnection = connection;
            }

            // register connection listener
            isInitialized = true;
        }

        // notify initial connection
        lastRefreshPeriodMs = getRefreshPeriodMs();
        setConnection(initialConnection, initialInfo);
    }

    public boolean isAutoSwitch() {
        return connectionList.getAutoSwitch() || !coreContext.isApiUser(); // auto switch always enabled on desktop ui
    }

    public void startLocalNode() throws Exception {
        
        // cannot start local node as seed node
        if (HavenoUtils.isSeedNode()) {
            throw new RuntimeException("Cannot start local node on seed node");
        }

        // start local node
        log.info("Starting local node");
        localNodeStartedFromPrompt = true;
        xmrLocalNode.start();
    }

    private void updatePolling(MoneroDaemonInfo applyInfo) {
        synchronized (lock) {
            stopPolling();
            if (connectionList.getRefreshPeriod() >= 0) startPolling(applyInfo); // 0 means default refresh poll
        }
    }

    private void startPolling(MoneroDaemonInfo applyInfo) {
        synchronized (lock) {
            stopPolling();
            numConsecutiveErrors = 0;
            AtomicBoolean firstPoll = new AtomicBoolean(true);
            monerodPoller = new TaskLooper(() -> {
                if (!pollInProgress) {
                    tryPollMonerod(firstPoll.get() ? applyInfo : null);
                }
                firstPoll.set(false);
            });
            monerodPoller.start(getInternalRefreshPeriodMs());
        }
    }

    private void stopPolling() {
        synchronized (lock) {
            if (monerodPoller != null) {
                monerodPoller.stop();
                monerodPoller = null;
            }
        }
    }

    private boolean isPolling() {
        synchronized (lock) {
            return monerodPoller != null;
        }
    }

    private void tryPollMonerod(MoneroDaemonInfo applyInfo) {
        try {
            doPollMonerod(applyInfo);
        } catch (Exception e) {
            // error is already handled
        }
    }

    /**
     * Polls monerod for the latest info and updates the connection if necessary.
     * 
     * @param applyInfo applies the given info instead of fetching from monerod
     */
    private void doPollMonerod(MoneroDaemonInfo applyInfo) {
        synchronized (pollLock) {
            if (isShutDownStarted) return;
            pollInProgress = true;
            try {

                // check monero connection with error tolerance
                MoneroRpcConnection connection = getConnection();
                try {

                    // throw if no monerod
                    if (monerod == null) throw new RuntimeException("No connection to Monero node.");

                    // check the monero connection or use applied info
                    if (applyInfo == null) {
                        checkConnection(connection);
                        MoneroDaemonInfo info = getCachedDaemonInfo(connection);
                        if (info == null) throw new RuntimeException("Could not get latest info from the Monero node.");
                        lastInfo = info;
                    } else {
                        lastInfo = applyInfo;
                    }

                    // throw if no peer connections
                    if (getNumOutgoingConnections(lastInfo) == 0) {
                        throw new RuntimeException("The Monero node has no connected peers. It may be experiencing a network connectivity issue.");
                    }

                    // reset error count on success
                    numConsecutiveErrors = 0;
                } catch (Exception e) {

                    // skip handling if shutting down
                    if (isShutDownStarted) return;

                    // skip error handling up to max attempts
                    numConsecutiveErrors++;
                    if (numConsecutiveErrors < getMaxConsecutiveErrors()) {

                        // attempt to switch if never synced unless polling stopped
                        if (!wasMonerodSynced && canSwitchToBestConnection() && isPolling()) {
                            switchToBestConnection();
                        }
                        return;
                    } else {
                        numConsecutiveErrors = 0; // reset error count
                    }

                    // log error message periodically
                    boolean lastWarningOutsidePeriod = lastLogPollErrorTimestamp == null || System.currentTimeMillis() - lastLogPollErrorTimestamp > HavenoUtils.LOG_POLL_ERROR_PERIOD_MS;
                    if (lastWarningOutsidePeriod) {
                        log.warn("Error fetching daemon info after max attempts ({}). monerod={}, error={}", getMaxConsecutiveErrors(), connection == null ? "null" : connection.getUri(), e.getMessage());
                        if (DevEnv.isDevMode()) log.error(ExceptionUtils.getStackTrace(e));
                        lastLogPollErrorTimestamp = System.currentTimeMillis();
                    }

                    // invoke fallback handling on startup error
                    boolean canFallback = !wasMonerodSynced && (isFixedConnection() || isProvidedConnections() || isCustomConnections() || usedSyncingLocalNodeBeforeStartup);
                    if (!fallbackApplied && canFallback && connectionServiceFallbackType.get() == null && (lastFallbackInvocation == null || System.currentTimeMillis() - lastFallbackInvocation > FALLBACK_INVOCATION_PERIOD_MS)) {
                        lastFallbackInvocation = System.currentTimeMillis();
                        if (usedSyncingLocalNodeBeforeStartup && !xmrLocalNode.isDetected()) {
                            log.warn("Could not get monerod info from local connection on startup: " + e.getMessage());
                            connectionServiceFallbackType.set(XmrConnectionFallbackType.LOCAL);
                            return;
                        } else if (isProvidedConnections()) {
                            log.warn("Could not get monerod info from provided connections on startup: " + e.getMessage());
                            connectionServiceFallbackType.set(XmrConnectionFallbackType.PROVIDED);
                            return;
                        } else if (isCustomConnections()) {
                            log.warn("Could not get monerod info from custom connection on startup: " + e.getMessage());
                            connectionServiceFallbackType.set(XmrConnectionFallbackType.CUSTOM);
                            return;
                        }
                    }

                    // skip further error handling if awaiting prompt
                    if (connectionServiceFallbackType.get() != null) return;

                    // try switching to next best connection unless polling stopped
                    if (canSwitchToBestConnection() && isPolling()) {
                        MoneroRpcConnection newConnection = switchToBestConnection(Arrays.asList(connection), lastWarningOutsidePeriod);
                        if (newConnection == null) throw e;
                        return;
                    } else {
                        throw e;
                    }
                }

                // connected to monerod
                isConnected = true;
                connectionServiceFallbackType.set(null);

                // set chain height
                chainHeight.set(getHeight());

                // save if blockchain is syncing locally
                boolean blockchainSyncingLocally = isConnectionLocalHost() && lastInfo.getHeight().equals(lastInfo.getHeightWithoutBootstrap()) || (lastInfo.getTargetHeight().equals(0l) && lastInfo.getHeightWithoutBootstrap().equals(0l)); // blockchain is syncing if height equals height without bootstrap, or target height and height without bootstrap both equal 0
                preferences.getXmrNodeSettings().setSyncBlockchain(blockchainSyncingLocally); // TODO: this isn't saved until all services initialized

                // throttle warnings if monerod not synced
                if (!isSyncedWithinTolerance() && System.currentTimeMillis() - lastLogMonerodNotSyncedTimestamp > HavenoUtils.LOG_MONEROD_NOT_SYNCED_WARN_PERIOD_MS) {
                    log.warn("Our chain height: {} is out of sync with peer nodes chain height: {}", getHeight(), getTargetHeight());
                    lastLogMonerodNotSyncedTimestamp = System.currentTimeMillis();
                }

                // announce connection change if refresh period changes
                if (getRefreshPeriodMs() != lastRefreshPeriodMs) {
                    pollInProgress = false;
                    setConnection(getConnection(), lastInfo); // resets polling
                    return;
                }

                // handle error recovery
                if (lastLogPollErrorTimestamp != null) {
                    log.info("Successfully fetched monerod info after previous error");
                    lastLogPollErrorTimestamp = null;
                }

                // clear error message
                getConnectionServiceErrorMsg().set(null);
            } catch (Exception e) {

                // not connected to monerod
                isConnected = false;

                // skip if shut down
                if (isShutDownStarted) return;

                // format error message
                String errorMsg = e.getMessage();
                if (errorMsg != null && errorMsg.contains(": ")) {
                    errorMsg = errorMsg.substring(errorMsg.indexOf(": ") + 2); // strip exception class
                }
                errorMsg = Res.get("popup.warning.moneroConnection", errorMsg);

                // set error message unless fallback prompt is shown
                getConnectionServiceErrorMsg().set(errorMsg);
                throw e;
            } finally {
                pollInProgress = false;
                updateProperties();
            }
        }
    }

    private boolean isFixedConnection() {
        return !"".equals(config.xmrNode) && !(HavenoUtils.isLocalHost(config.xmrNode) && xmrLocalNode.shouldBeIgnored()) && !fallbackApplied;
    }

    private boolean isCustomConnections() {
        return preferences.getMoneroNodesOption() == XmrNodes.MoneroNodesOption.CUSTOM;
    }

    private boolean isProvidedConnections() {
        return preferences.getMoneroNodesOption() == XmrNodes.MoneroNodesOption.PROVIDED;
    }

    private int getMaxConsecutiveErrors() {
        return isConnectionLocalHost() ? 3 : 4; // allow more errors on remote connections
    }

    private void updateProperties() {
        UserThread.execute(() -> {

            // update sync progress
            if (lastInfo != null) {
                long height = getHeight();
                long targetHeight = getTargetHeight();
                if (height >= targetHeight) doneDownload();
                else {
                    long blocksRemaining = targetHeight - height;
                    if (syncStartHeight == null) syncStartHeight = height;
                    double percent = Math.min(1.0, targetHeight == syncStartHeight ? 1.0 : ((double) Math.max(1, height - syncStartHeight) / (double) (targetHeight - syncStartHeight))); // grant at least 1 block to show progress
                    downloadListener.progress(percent, blocksRemaining);
                }
            }

            // set available connections
            List<MoneroRpcConnection> availableConnections = new ArrayList<>();
            synchronized (connections) {
                for (MoneroRpcConnection connection : connections) {
                    if (Boolean.TRUE.equals(connection.isOnline()) && Boolean.TRUE.equals(connection.isAuthenticated())) {
                        availableConnections.add(connection);
                    }
                }
            }
            connectionsProperty.set(availableConnections);
            numConnections.set(getNumOutgoingConnections(lastInfo));

            // notify update
            numUpdates.set(numUpdates.get() + 1);
        });
    }
}
